# Java
<br>

-----------------------
### Java 버전 별 특징

<details>
   <summary> JAVA 1.8</summary>
<br />

-----------------------
#### [ 람다 표현식 ] 

람다 표현식은 간단히 말해 메소드를 하나의 식으로 표현한 것이다.  
즉, 식별자 없이 실행할 수 있는 함수 표현식을 의미하며, 익명 함수라고도 부른다.

메소드를 이렇게 람다 표현식으로 표현하면 클래스를 만들고 객체를 생성하지 않아도 메소드를 사용 할 수 있다.  
또한, 람다 표현식은 메소드의 매개 변수로 전달 될 수도 있고, 메소드의 결괏값으로 반환될 수도 있다.

이러한 람다 표현식은 **_기존의 불필요한 코드를 줄여주고, 작성 된 코드의 가독성을 높이는데 목적이 있다._**

-----------------------

#### [ 람다 표현식 사용시 유의할점 ] 
1. 매개 변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있다.
2. 매개변수가 하나인 경우에는 괄호( () )를 생략할 수 있다.
3. 함수의 몸체가 하나인 명령문만으로 이루어진 경우에는 중괄호( {} )를 생략할 수 있다.
4. 함수의 몸체가 하나의 return문으로만 이루어진 경우에는 중괄호( {} )를 생략할 수 없다.
5. return문 대신 표현식을 사용 할 수 있으며, 이떄 반환값은 표현식의 결괏값이 된다.

-----------------------

#### [ 함수형 인터페이스 ]
단 하나의 추상 메소드를 갖는 인터페이스를 함수형 인터페이스라고 한다.
 
또한, 함수형 인터페이스를 컴파일 시점에 컴파일러가 인식할 수 있도록 ```@FunctionalInterface``` 어노테이션을 제공한다.
자바 컴파일러는 컴파일시 함수형 인터페이스에 두 개 이상의 메소드가 선언되면 오류를 발생시킨다.  
(```@FunctionalInterface```을 생략해도 함수형 인터페이스이지만, 컴파일러가 인식하지는 못한다)

-----------------------

#### [ 인터페이스 default 메소드 ]
기존에는 인터페이스에 메소드 정의만 할 수 있었지만, java 1.8부터는 ```default``` 키워드를 사용하여 메소드를 구현할 수 있다.  
이러한 default 메소드는 코드 호환성을 유지하면서 새로운 기능을 추가할 수 있는 이점이 있다.  
(기존의 인터페이스 구현들의 변경 없이 공통적인 기능을 제공해야 할때)

-----------------------

#### [ Stream API ]
자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용한다.  
또한, 이렇게 저장 된 데이터의 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 코드를 작성해야 했다.

하지만 이렇게 작성한 코드는 가독성이 떨어지고, 재사용이 힘들었다.  
또한, 데이터베이스의 쿼리와 같은 정형화된 처리 패턴을 가지기 못했기에 데이터마다 다른 방법으로 접근해야했다.

이러한 문제점을 극복하기 위해 도입 된 방법이 Stream API이다.
Stream API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장 된 데이터를 읽고 쓰기 위한 공통 된 방법을 제공한다.  
따라서 Stream API를 사용하면 배열이나 컬렉션뿐만 아니라 파일에 저장 된 데이터도 모두 같은 방법으로 다룰 수 있다.

-----------------------

#### [ Stream API 특징 ]
(1) 파이프라인을 지원한다.  
메소드 체이닝으로 연결된다. ```filter(), sorted(), map(), collect()```등이 계속 이어진다.  
이렇게 스트림 객체끼리 연속으로 처리하면서 하나의 파이프라인이 되어 최종적인 결괏값을 반환하게 된다.  


(2) 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복을 통해 작업을 수행한다.  

코드 외부에서 for문을 사용하지 않고 ```filter()```처럼 내부에서 알아서 처리한다.  
그래서 코드를 분석하는데 방해되는 요인을 줄이고 비지니스 로직 구현에만 충실한 코드를 짤 수 있다.

for문이 없는 것이 아니라 보이지 않는 것뿐이니 성능이 중요한 애플리케이션에서는 상황에 따라 외부 반복을 통해 구현하는 것이 이점을 얻을 수 있다.


(4) 원본 데이터를 변경하지 않는다.

재사용이 가능한 컬렉션과는 달리 단 한번만 사용할 수 있다.  
스트림의 기능을 거치게 되면 이전 상태로 돌아갈 수 없다.

**_무슨 뜻이냐면 연산 이전의 값을 저장하지 않고, 연산 된 값만 새롭게 반환한다는 뜻이다._**  
(변수에 스트림을 저장해두고 재사용할 수 있지만, 스트림은 소비 중심의 개발 철학을 지니고 있기 때문에 데이터를 필요에 맞게 소비하는 것이 사상적으로 어울린다.)


(5) 스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(Lazy) 연산을 통해 성능을 최적화한다.

프로그래밍에서 Lazy하게 동작하는 의미는 필요한 시점까지 실행을 미루다가 특정 시점이 되면 동작하는 기법을 말한다.

스트림은 종료 연산이 없으면 중간 연산을 실행하지 않는다. 이말은 아무리 중간 연산이 복잡해도 종료 연산이 없다면 실행하지 않는다는 의미이다.


(6) parallelStream() 메소드를 통해 병렬 처리를 지원한다.

-----------------------

#### [ Stream API 동작 흐름 ]
스트림 API는 3가지 단계에 걸쳐서 동작한다.

1. 스트림 생성
2. 스트림의 중개 연산
3. 스트림의 최종 연산

-----------------------

#### [ Optional ]
Java가 가지고 있는 null의 문제점을 보완하고자 등장하였다.  
Optional은 null 또는 값을 감싸서 NPE로부터 부담을 줄이기 위해 등장한 Wrapper 클래스이다. 

Optional은 값을 Wrapping하고 다시 풀고, null 일 경우에는 대체하는 함수를 호출하는 등의 오버헤드가 있으므로 잘못 사용하면 시스템 성능이 저하된다.  
그렇기 때문에 메소드의 반환 값이 절대 null이 아니라면 Optional을 사용하지 않는 것이 좋다. 즉 Optional은 메소드의 결과가 null이 될 수 있으며, null에 의해 오류가 발생할 가능성이 매우 높을 때 반환값으로만 사용되어야 한다.

또한 Optional은 파라미터로 넘어가는 등이 아니라 반환 타입으로써 제한적으로 사용되도록 설계되어있다.

장점
- NPE 방지 : Optional은 값이 있는지 없는지 명시적으로 나타내므로 NPE를 방지할 수 있다. 값을 다루는 메서드 체인을 사용할 때에도 값의 존재 여부를 확인할 수 있어 안정성이 향상된다.
- 가독성 향상 : Optional을 사용하면 값의 존재 여부를 명확하게 표현할 수 있으므로 코드의 가독성이 향상된다. 값을 다루는 로직을 Optional 메서드 체인으로 표현할 수 있어 코드가 더 간결해진다.
- API 설계의 명확성 : Optional을 메서드의 반환 타입으로 사용하면, 해당 메서드가 값이 없을 수도 있다는 것을 명시적으로 표현할 수 있다. 이는 API 사용자에게 해당 값을 항상 가지고 있을 것이라는 가정을 하지 않도록 도와준다.
- Null 체크 간소화 : 값을 사용하기 전에 null 체크를 하지 않아도 된다. Optional에서 제공하는 메서드들을 사용하여 값의 존재 여부를 확인하고 안전하게 접근할 수 있다. 

단점
- 성능 오버헤드 : Optional은 값을 감싸는 래퍼 클래스로 추가적인 메모리와 약간의 성능 오버헤드를 발생시킬 수 있다. 값이 있는 경우에도 Optional 객체를 생성하고 관리해야하므로 일부 상황에서는 성능 저하가 발생할 수 있다. 그러나 대부분의 상황에서는 미세한 비용이므로 큰 문제가 되지는 않는다.
- 남용의 가능성 : Optional을 과도하게 사용하거나 잘못 사용하는 경우, 코드의 가독성이 오히려 저하될 수 있다. 모든 변수나 반환 타입에 Optional을 사용하는 것은 좋은 방법이 아니다. Optional은 값이 없을 수도 있는 상황에서 사용하는 것이 적합하다.

-----------------------

#### [ Optional을 올바르게 사용해야 하는 이유 ]
NullPointException 대신 NoSuchElementException이 발생함

<br />
Optional을 사용하면 코드가 Null-Safe해지고, 가독성이 좋아지며 애플리케이션이 안정적이 된다는 등과 같은 애기들을 많이 접할 수 있다.
하지만 이는 Optional

-----------------------

#### [ java.time 패키지 ]
java 1.8 이전까지는 Date 클래스와 Calendar 클래스를 사용하여 날짜와 시간에 대한 정보를 처리할 수 있었지만, 다음과 같은 문제점을 지니고 있었다.
1. Calendar 인스턴스는 불변 객체가 아니라서 값이 수정될 수 있다.
2. 윤초(leap second)와 같은 특별한 상황을 고려하지 않는다.
3. Calendar 클래스는 월을 나타낼 때 1~12월을 0~11까지로 표현해야하는 불편함이 있다.

java 1.8 부터는 위 문제점을 개선한 java.time 패키지를 제공하며, 다음과 같은 다양한 기능을 제공하는 하위 패키지를 포함하고 있다.
1. java.time.chrono : ISO-8601에 정의 된 표준 달력 이외의 달력 시스템을 사용할 때 필요한 클래스들
2. java.time.format : 날짜와 시간에 대한 데이터를 구문분석하고 형식화하는데 사용되는 클래스들
3. java.time.temporal : 날짜와 시간에 대한 데이터를 연산하는데 사용되는 보조 클래스들
4. java.time.zone : 타임존과 관련 된 클래스들
5. LocalDate 클래스 : 날짜를 표현할 때 사용하는 클래스
6. LocalTime 클래스 : 시간을 표현할 때 사용하는 클래스
7. LocalDateTime 클래스 : 날짜와 시간을 표현할 때 사용하는 클래스
8. ZonedDateTime 클래스 : 특정 타임존에 해당하는 날짜와 시간을 다루는데 사용하는 클래스
9. Instant 클래스 : 특정 시점의 날짜와 시간을 나노 단위로 표현하는 타임스탬프를 다루는데 사용하는 클래스
10. Period 클래스 : 두 날짜 사이의 차이를 표현하는데 사용하는 클래스
11. Duration 클래스 : 두 시각 사이의 차이를 표현하는데 사용하는 클래스

-----------------------
#### [ 참고 사이트 ]
http://www.tcpschool.com/java/java_intro_java8  
http://www.tcpschool.com/java/java_lambda_concept  
http://www.tcpschool.com/java/java_stream_concept  
http://www.tcpschool.com/java/java_time_javaTime  
http://www.tcpschool.com/java/java_stream_optional  
</details>

-----------------------

<details>
   <summary> JAVA 11</summary>
<br />

| Type | Features                            | Content                                                                                                               |
|------|-------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| 패키지  | Jigsaw 모듈 시스템                       | 모듈을 만들고 해당 모듈은 외부에서 호출할 수 있는 API를 제공하여, 언어레벨에선 직접적으로 해당 모듈에 접근이 불가능                                                   |
| 패키지  | New Garbase Collector, ZGC 추가       | 새로운 Garbage Collector 도입                                                                                              |
| 패키지  | Thread_Local Handshakes             | GC 실행 전 우선 발생하는 "STOP-THE-WORLD" 발생시 이전에는 모든 Thread가 동시에 중단 되었다면, 이제는 Thread 개별로 중단 가능                                |
| 패키지  | JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리 할당 | HotSpot JVM이 사용자가 지정한 대체 메모리 장치 또는 서로 다른 메모리장치를 이용해서 JVM Heap 영역의 메모리를 할당                                             |
| 패키지  | Multi-Release Jar File              | JAR 파일 형식을 확장하여 여러 버전의 클래스 파일을 하나의 JAR안에 공존 가능                                                                        |
| 지원도구 | JShell                              | Main Method 없이 자바 코드를 넣고 즉석에서 실행 가능 한 도구                                                                              |
| 기능   | Collection Factory Method 기능 강화     | List, Set, Map 인터페이스에 immutable 생성을 할 수 있는 새로운 Method(List.of(), Set.of() 등) 추가                                       |
| 기능   | Interface, Private Method 도입        | 인터페이스 내 private Method 사용 가능                                                                                          |
| 기능   | Optional ifPresentOrElse Method 추가  | 기존 ifPresent Method 경우 Optional 객체가 값을 담고 있는 경우만 처리하였으나, 추가 된 ifPresentOrElse Method는 해당 객체가 값이 없을 경우 처리할 내용까지 정의가 가능 |


</details>
